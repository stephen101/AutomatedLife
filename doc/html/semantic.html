<HTML>

<!----------------------------------------------------------------------------->
<!--                  START OF AUTOMATICALLY GENERATED HTML FILE             -->
<!----------------------------------------------------------------------------->
<!--                                                                         -->
<!-- This HTML file was generated by the FunnelWeb literate programming      -->
<!-- preprocessor. You can display this file using popular web browsers      -->
<!-- such as Netscape Navigator and Microsoft Internet Explorer.             -->
<!--                                                                         -->
<!-- FunnelWeb is a preprocessor that allows programmers to weave programs   -->
<!-- and their documentation together in a single document. The FunnelWeb    -->
<!-- program analyses such documents producing both program files and        -->
<!-- typeset documentation such as this HTML file.                           -->
<!--                                                                         -->
<!-- FunnelWeb was created by Ross N. Williams (www.ross.net) and is         -->
<!-- available free of charge under a GNU General Public Licence.            -->
<!-- The FunnelWeb website can be found at http://www.ross.net/funnelweb/    -->
<!--                                                                         -->
<!----------------------------------------------------------------------------->

<HEAD>

<TITLE>Package semantic</TITLE>

<STYLE TYPE="text/css">
<!--
A {text-decoration: none}
H1 { font-family: sans-serif; font-size: large }
H2 { font-family: sans-serif; font-size: medium; font-weight: bold }
H3 { font-family: sans-serif; font-size: medium }
H4 { font-family: sans-serif; font-size: small }
H5 { font-family: sans-serif; font-size: small }
// -->
</STYLE>

</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#CC0033 VLINK=#CC0033 ALINK=#CC0000>

<BR>

<BR>

<BR>

<BR>

<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=7>Semantic Engine Core C++ API</FONT></DIV>
</TD></TR></TABLE><BR>
<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=4>By Gabriel Schine</FONT></DIV>
</TD></TR></TABLE><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>

This file describes the <B>Semantic Engine</B> core API. All the main
functionality of the <B>Semantic Engine</B> is described here,
supplemented by the documentation in <FONT COLOR=#000033><TT>subgraph.hpp</TT></FONT>, which
describes the sub-graph capabilities of the <B>Semantic Engine</B>.

<P></TD></TR></TABLE>
<BR>


<A HREF="#sec_1">1. Semantic Engine Core API</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.1">1.1. Graph-Based Indexing</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.2">1.2. Policy-Based Functionality</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3">1.3. Base class SEGraph</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3.1">1.3.1. Constructor</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3.2">1.3.2. Accessing Properties</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3.3">1.3.3. Weighting the Edges</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3.4">1.3.4. Structure Modification Member Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3.4.1">1.3.4.1. Pruning Helper Methods</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4">1.4. Related Non-member Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.1">1.4.1. add_vertex</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.2">1.4.2. add_edge</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.3">1.4.3. add_or_strengthen_edge</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.4">1.4.4. remove_edge</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.5">1.4.5. remove_out_edge_if</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.6">1.4.6. remove_in_edge_if</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.7">1.4.7. remove_edge_if</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.8">1.4.8. clear_vertex</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.9">1.4.9. clear_out_edges</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.10">1.4.10. clear_in_edges</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.11">1.4.11. remove_vertex</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.12">1.4.12. merge_vertices</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.13">1.4.13. either_edge</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4.14">1.4.14. ostream output</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.5">1.5. Managing Indices</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.6">1.6. Using Smart Pointers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.7">1.7. The File: semantic.hpp</A><BR>

<P><HR SIZE=4 NOSHADE><P><A NAME="sec_1"></A>
<H1>1. Semantic Engine Core API</H1>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This file describes the <B>Semantic Engine</B> core API. All the main
functionality of the <B>Semantic Engine</B> is described here,
supplemented by the documentation in <FONT COLOR=#000033><TT>subgraph.hpp</TT></FONT>, which
describes the sub-graph capabilities of the <B>Semantic Engine</B>.

<P></TD></TR></TABLE>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.1"></A>
<H2>1.1. Graph-Based Indexing</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The <B>Semantic Engine</B> stores indices in a graph. A graph is
a number of nodes and edges, with edges "connecting" two
nodes together. The graph is bipartite in nature, directed
and cannot have parallel edges. Any tools using the
text-indexing features of the <B>Semantic Engine</B> can assume
that a document node will always be connected to a term
node, and vice versa.

<P>Heavy usage of the <B>BOOST</B> C++ Libraries (http://boost.org/)
at the core of the <B>Semantic Engine</B> API offers stability and
a common interface between <B>BOOST</B> libraries and the libraries
of the <B>Semantic Engine</B>.

<P>The <B>Semantic Engine</B> API supplies extensions to the <B>BGL</B>
(<B>BOOST</B> Graph Library). All functions are overloaded in
the <FONT COLOR=#000033><TT>boost::*</TT></FONT> namespace. In this way, coders familiar with
the <B>BOOST</B> API will easily transition into the <B>Semantic</B> API.

<P></TD></TR></TABLE>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.2"></A>
<H2>1.2. Policy-Based Functionality</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Much of the power of the <B>Semantic Engine</B> comes from the leverage
of policy-based programming. Policies are template arguments to the
<B>Semantic Engine</B> base class (<FONT COLOR=#000033><TT>SEGraph</TT></FONT>) which alter core
functionality. For <FONT COLOR=#000033><TT>SEGraph</TT></FONT>, the <B>Storage Policy</B> is chosen by
passing a <B>Storage Policy Selector</B> type to the class. <B>Storage
Policies</B> determine how an index will persist across program runs.
A number of <B>Storage Policies</B> are included (see the files under <FONT COLOR=#000033><TT>storage/</TT></FONT>) and others can be easily
written (see <FONT COLOR=#000033><TT>storage/concept.hpp</TT></FONT> for details).

<P></TD></TR></TABLE>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.3"></A>
<H2>1.3. Base class SEGraph</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This class is at the core of the <B>Semantic Engine</B>. Its construction
is a little complicated, so if you're trying to understand it, please
try to read through this entire section.

<P>To access <FONT COLOR=#000033><TT>NoStoragePolicy</TT></FONT> and the <FONT COLOR=#000033><TT>se_graph_traits</TT></FONT> below we need
to include the appropriate files:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="1"></A>1. <A HREF="#31">includes</A>+={<FONT COLOR=#000033><TT><BR>
#include&nbsp;&lt;semantic/config.hpp&gt;<BR>
#include&nbsp;&lt;semantic/storage/none.hpp&gt;<BR>
#include&nbsp;&lt;semantic/properties.hpp&gt;<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#1">1</A> and <A HREF="#9">9</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<FONT COLOR=#CC0033>
<P><A NAME="2"></A>2. <A HREF="#31">SEGraph</A>={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;StoragePolicySelector&nbsp;=&nbsp;NoStoragePolicy,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;SEBase&nbsp;=&nbsp;StoragePolicy&lt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StoragePolicySelector,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::base_graph_type&nbsp;&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;class&nbsp;SEGraph&nbsp;:&nbsp;public&nbsp;SEBase<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;self_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;storage_traits&lt;StoragePolicySelector&gt;&nbsp;storage_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;se_traits;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#3">SEGraph public scope</A><TT><BR>
};<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The <FONT COLOR=#000033><TT>SEGraph</TT></FONT> is built such that every class up the inheritance tree
can be customized at type definition time. The class's parent type: <FONT COLOR=#000033><TT>SEBase</TT></FONT>
is defined as the <FONT COLOR=#000033><TT>StoragePolicy</TT></FONT> template class. <FONT COLOR=#000033><TT>StoragePolicy</TT></FONT> classes
take two template arguments, the first being the <FONT COLOR=#000033><TT>StoragePolicySelector</TT></FONT>.
This type is an empty struct defined by a <B>Storage Policy</B>, coupled with
a definition of <FONT COLOR=#000033><TT>StoragePolicy&lt;StoragePolicySelector, SEBase&gt;</TT></FONT>. The struct
<FONT COLOR=#000033><TT>se_graph_traits</TT></FONT> lives in the <FONT COLOR=#000033><TT>semantic::*</TT></FONT> namespace and is defined
in <FONT COLOR=#000033><TT>properties.hpp</TT></FONT>. <FONT COLOR=#000033><TT>se_graph_traits&lt;StoragePolicySelector&gt;::base_graph_type</TT></FONT>
is a <B>BOOST</B> graph type. The <FONT COLOR=#000033><TT>SEBase</TT></FONT> template argument should never be
altered. It was left open for future development.

<P>The following typedefs are made publicly available by the <FONT COLOR=#000033><TT>SEGraph</TT></FONT> class.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="3"></A>3. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
typedef&nbsp;SEBase&nbsp;base_type;<BR>
typedef&nbsp;typename&nbsp;se_traits::base_graph_type&nbsp;base_graph_type;<BR>
typedef&nbsp;StoragePolicySelector&nbsp;storage_policy_selector;<BR>
typedef&nbsp;base_type&nbsp;storage_policy_type;<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.3.1"></A>
<H3>1.3.1. Constructor</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The constructor is simple, and accepts only the name of the collection to
which this graph should be tied. All operations performed on this graph
will only affect the collection named in the constructor. For this reason,
<B>if multiple operations on multiple collections is desired, you must create
multiple graph objects!</B></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="4"></A>4. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
SEGraph()&nbsp;{&nbsp;SEGraph("");&nbsp;}<BR>
explicit&nbsp;SEGraph(string&nbsp;name)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;base_type(),&nbsp;__refcount(0)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;storage_policy_type::set_mirror_changes_to_storage(false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set_property(*this,&nbsp;graph_name,&nbsp;name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set_property(*this,&nbsp;graph_energy_hits,&nbsp;1);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.3.2"></A>
<H3>1.3.2. Accessing Properties</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>In order to access vertex and edge properties (see
<FONT COLOR=#000033><TT>se_graph_traits&lt;StoragePolicySelector&gt;::vertex_properties_type</TT></FONT>
and <FONT COLOR=#000033><TT>se_graph_traits&lt;StoragePolicySelector&gt;::edge_properties_type</TT></FONT>),
we need to create accessor methods to get to them quickly. These
methods exactly mirror those available in the <B>BGL</B>.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="5"></A>5. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
typename&nbsp;storage_traits::vertex_properties_type&nbsp;&amp;<BR>
operator&nbsp;[]&nbsp;(typename&nbsp;se_traits::vertex_descriptor&nbsp;v)&nbsp;{&nbsp;return&nbsp;(get(vertex_bundle,&nbsp;*this))[v];&nbsp;}<BR>
const&nbsp;typename&nbsp;storage_traits::vertex_properties_type&nbsp;&amp;<BR>
operator&nbsp;[]&nbsp;(typename&nbsp;se_traits::vertex_descriptor&nbsp;v)&nbsp;const&nbsp;{&nbsp;return&nbsp;(get(vertex_bundle,&nbsp;*this))[v];&nbsp;}<BR>
typename&nbsp;storage_traits::edge_properties_type&nbsp;&amp;<BR>
operator&nbsp;[]&nbsp;(typename&nbsp;se_traits::edge_descriptor&nbsp;e)&nbsp;{&nbsp;return&nbsp;(get(edge_bundle,&nbsp;*this))[e];&nbsp;}<BR>
const&nbsp;typename&nbsp;storage_traits::edge_properties_type&nbsp;&amp;<BR>
operator&nbsp;[]&nbsp;(typename&nbsp;se_traits::edge_descriptor&nbsp;e)&nbsp;const&nbsp;{&nbsp;return&nbsp;(get(edge_bundle,&nbsp;*this))[e];&nbsp;}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>And this one allows you to get the name of the collection to which this graph
is tied.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="6"></A>6. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
std::string&nbsp;collection()&nbsp;const&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;get_property(*this,&nbsp;graph_name);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.3.3"></A>
<H3>1.3.3. Weighting the Edges</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The following method is supplied as a convenience method. The <FONT COLOR=#000033><TT>WeightingPolicy</TT></FONT>
defines the algorithm to use to apply weights to the supplied <FONT COLOR=#000033><TT>WeightMap</TT></FONT>.

<P>More information on <B>Weighting Policies</B> can be found in the
<FONT COLOR=#000033><TT>weighting/</TT></FONT> subdirectory.

<P>The <FONT COLOR=#000033><TT>WeightMap</TT></FONT> must be a <B>BOOST</B> property map keyed by edge.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="7"></A>7. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;WeightingPolicy,&nbsp;class&nbsp;WeightMap&gt;<BR>
void&nbsp;populate_weight_map(WeightingPolicy&nbsp;weighting,&nbsp;WeightMap&nbsp;w)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;WeightingPolicy::weight_type&nbsp;weight_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;se_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;se_traits::vertex_iterator&nbsp;iterator;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;make&nbsp;sure&nbsp;we&nbsp;were&nbsp;passed&nbsp;the&nbsp;right&nbsp;kind&nbsp;of&nbsp;WeightMap<BR>
&nbsp;&nbsp;&nbsp;&nbsp;function_requires&lt;&nbsp;WritablePropertyMapConcept&lt;WeightMap,&nbsp;Edge&gt;&nbsp;&gt;();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;BOOST_STATIC_ASSERT((boost::is_same&lt;typename&nbsp;boost::property_traits&lt;WeightMap&gt;::value_type,&nbsp;weight_type&gt;::value));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;go&nbsp;through&nbsp;all&nbsp;the&nbsp;vertices&nbsp;and&nbsp;apply&nbsp;our&nbsp;weighting&nbsp;algorithm<BR>
&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;vi,&nbsp;vi_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(vi,&nbsp;vi_end)&nbsp;=&nbsp;vertices(*this);&nbsp;vi&nbsp;!=&nbsp;vi_end;&nbsp;++vi)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weighting.apply_weights(*vi,&nbsp;*this,&nbsp;w);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.3.4"></A>
<H3>1.3.4. Structure Modification Member Functions</H3>
<FONT COLOR=#CC0033>
<P><A NAME="8"></A>8. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
void&nbsp;clear()&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;storage_policy_type::will_clear();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type::clear();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;storage_policy_type::did_clear();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>clear()</TT></FONT> overrides the function of the same name in the <B>BGL</B>. Here
the <B>Storage Policy</B> gets a chance to perform any operations before
and after the actual clearing of the in-memory graph.

<P></TD></TR></TABLE>
<P><HR SIZE=2><P><A NAME="sec_1.3.4.1"></A>
<H4>1.3.4.1. Pruning Helper Methods</H4>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The following methods are helpers that make it easy to apply pruning
operations to a graph, its vertices or edges. See the file <FONT COLOR=#000033><TT>pruning.hpp</TT></FONT>
for example (and useful!) pruning methods.

<P>These methods make heavy use of the <B>BOOST</B> graph iteration macros:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="9"></A>9. <A HREF="#31">includes</A>+={<FONT COLOR=#000033><TT><BR>
#include&nbsp;&lt;boost/graph/iteration_macros.hpp&gt;<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#1">1</A> and <A HREF="#9">9</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<FONT COLOR=#CC0033>
<P><A NAME="10"></A>10. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;Functor&gt;<BR>
void&nbsp;apply_to_graph(Functor&nbsp;f)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;f(*this);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>For <FONT COLOR=#000033><TT>apply_to_graph()</TT></FONT>, <FONT COLOR=#000033><TT>Functor</TT></FONT> must have an <FONT COLOR=#000033><TT>operator ()</TT></FONT> method defined and templated
on a single parameter (the <FONT COLOR=#000033><TT>Graph</TT></FONT> type).

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="11"></A>11. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;Functor&gt;<BR>
void&nbsp;apply_to_all_vertices(Functor&nbsp;f)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;BGL_FORALL_VERTICES_T(v,&nbsp;(*this),&nbsp;base_graph_type)&nbsp;f(v,&nbsp;*this);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>For <FONT COLOR=#000033><TT>apply_to_all_vertices()</TT></FONT>, <FONT COLOR=#000033><TT>Functor</TT></FONT> must have an <FONT COLOR=#000033><TT>operator ()</TT></FONT> method defined
and templated on at least the <FONT COLOR=#000033><TT>Graph</TT></FONT> (second) parameter. The first will be
a <FONT COLOR=#000033><TT>se_graph_traits&lt;Graph&gt;::vertex_descriptor</TT></FONT>, and can be templated out of
convenience if desired.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="12"></A>12. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;Functor&gt;<BR>
void&nbsp;apply_to_all_edges(Functor&nbsp;f)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;BGL_FORALL_EDGES_T(e,&nbsp;(*this),&nbsp;base_graph_type)&nbsp;f(e,&nbsp;*this);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>For <FONT COLOR=#000033><TT>apply_to_all_edges()</TT></FONT>, <FONT COLOR=#000033><TT>Functor</TT></FONT> must have an <FONT COLOR=#000033><TT>operator ()</TT></FONT>
method defined and be templated on at least the second parameter.
The first will be a <FONT COLOR=#000033><TT>se_graph_traits&lt;Graph&gt;::edge_descriptor</TT></FONT>
and can be templated out of convenience.

<P></TD></TR></TABLE>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.4"></A>
<H2>1.4. Related Non-member Functions</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Like in the <B>BGL</B>, there are a host of non-member functions that act
on the <FONT COLOR=#000033><TT>SEGraph</TT></FONT> class. The names and interfaces are taken directloy
frmo the <B>BGL</B>. Some functions that can be called safely from the
<B>BGL</B> cannot be used with <FONT COLOR=#000033><TT>SEGraph</TT></FONT>. Those functions will throw
an exception if called.

<P>All functions that can be called on a <B>BOOST</B> graph can also be called
on an <FONT COLOR=#000033><TT>SEGraph</TT></FONT>.

<P></TD></TR></TABLE>
<P><HR SIZE=3><P><A NAME="sec_1.4.1"></A>
<H3>1.4.1. add_vertex</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>add_vertex</TT></FONT> will add a vertex to the graph and return
the <FONT COLOR=#000033><TT>vertex_descriptor</TT></FONT>. You must supply
a <FONT COLOR=#000033><TT>vertex_properties_type</TT></FONT> struct to the function. (see
<FONT COLOR=#000033><TT>se_graph_traits&lt;Graph&gt;::vertex_properties_type</TT></FONT>)

<P>Before adding, it will ask the <B>Storage Policy</B> if
it should proceed. The <B>Storage Policy</B> might say no
if, for example, a vertex with similar properties already
exists, it might just update the properties already
in the graph and avoid adding a new vertex.

<P>After adding, it will tell the <B>Storage Policy</B> that
a new vertex was just added.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="13"></A>13. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor<BR>
add_vertex(const&nbsp;typename&nbsp;storage_traits&lt;StoragePolicySelector&gt;::vertex_properties_type&nbsp;&amp;p,&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::base_graph_type&nbsp;base_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits&lt;base_type&gt;::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;storage_traits&lt;StoragePolicySelector&gt;::vertex_properties_type&nbsp;vertex_properties_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;should_add;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boost::tie(should_add,&nbsp;v)&nbsp;=&nbsp;g.will_add_vertex(p);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;should&nbsp;we&nbsp;add&nbsp;this&nbsp;vertex?<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(should_add)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;boost::add_vertex(p,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.did_add_vertex(v,&nbsp;p);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;v;<BR>
}<BR>
<BR>
//&nbsp;THIS&nbsp;FUNCTION&nbsp;SHOULD&nbsp;NOT&nbsp;BE&nbsp;CALLED!&nbsp;USE&nbsp;add_vertex(properties,&nbsp;graph)&nbsp;INSTEAD<BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
add_vertex(SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DoNotUseThisMethodException&nbsp;{};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;DoNotUseThisMethodException();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.2"></A>
<H3>1.4.2. add_edge</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>add_edge</TT></FONT> will add an edge to the graph between two vertices. A set
of <FONT COLOR=#000033><TT>edge_properties_type</TT></FONT> will be attached to the edge. Like in
<FONT COLOR=#000033><TT>add_vertex</TT></FONT>, the <B>Storage Policy</B> will be asked if the edge
should be added or not. A <FONT COLOR=#000033><TT>std::pair&lt;edge_descriptor,bool&gt;</TT></FONT> will be
returned. If the <FONT COLOR=#000033><TT>bool</TT></FONT> is <FONT COLOR=#000033><TT>false</TT></FONT>, it means that the edge was
not added due to there already being an edge between those vertices, or
the <B>Storage Policy</B> denying edge addition.

<P>The <B>Storage Policy</B> will be notified of edge addition after the fact, as
well.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="14"></A>14. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;std::pair&lt;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::edge_descriptor,&nbsp;bool&gt;<BR>
add_edge(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;v,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;typename&nbsp;storage_traits&lt;StoragePolicySelector&gt;::edge_properties_type&nbsp;&amp;p,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;Edge,&nbsp;bool&gt;&nbsp;edge_result;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(g.will_add_edge(u,&nbsp;v,&nbsp;p))&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_result&nbsp;=&nbsp;boost::add_edge(u,&nbsp;v,&nbsp;p,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;if&nbsp;it&nbsp;already&nbsp;existed,&nbsp;update&nbsp;the&nbsp;properties<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(edge_result.second&nbsp;==&nbsp;false)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g[edge_result.first]&nbsp;=&nbsp;p;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.did_add_edge(edge_result.first,&nbsp;edge_result.second,&nbsp;u,&nbsp;v,&nbsp;p);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_result&nbsp;=&nbsp;std::make_pair(Edge(),&nbsp;false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;edge_result;<BR>
}<BR>
<BR>
//&nbsp;THIS&nbsp;FUNCTION&nbsp;SHOULD&nbsp;NOT&nbsp;BE&nbsp;CALLED!&nbsp;USE&nbsp;add_edge(vertex,&nbsp;vertex,&nbsp;properties,&nbsp;graph)&nbsp;INSTEAD<BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;std::pair&lt;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::edge_descriptor,&nbsp;bool&gt;<BR>
add_edge(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;v,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DoNotUseThisMethodException&nbsp;{};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;DoNotUseThisMethodException();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.3"></A>
<H3>1.4.3. add_or_strengthen_edge</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This function is identical to <FONT COLOR=#000033><TT>add_edge</TT></FONT>, except that if the edge already
exists, instead of updating the properties, the property's <FONT COLOR=#000033><TT>strength</TT></FONT>
member is increased by the value in the new property's field.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="15"></A>15. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;std::pair&lt;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::edge_descriptor,&nbsp;bool&gt;<BR>
add_or_strengthen_edge(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;v,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;typename&nbsp;storage_traits&lt;StoragePolicySelector&gt;::edge_properties_type&nbsp;&amp;p,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;Edge,&nbsp;bool&gt;&nbsp;edge_result;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(g.will_add_edge(u,&nbsp;v,&nbsp;p))&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_result&nbsp;=&nbsp;boost::add_edge(u,&nbsp;v,&nbsp;p,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;if&nbsp;it&nbsp;already&nbsp;exists,&nbsp;strengthen&nbsp;the&nbsp;edge<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(edge_result.second&nbsp;==&nbsp;false)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;graph_traits::edge_properties_type&nbsp;old_p&nbsp;=&nbsp;g[edge_result.first];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g[edge_result.first]&nbsp;=&nbsp;p;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g[edge_result.first].strength&nbsp;+=&nbsp;old_p.strength;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.did_add_edge(edge_result.first,&nbsp;edge_result.second,&nbsp;u,&nbsp;v,&nbsp;g[edge_result.first]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_result&nbsp;=&nbsp;std::make_pair(Edge(),&nbsp;false);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;edge_result;<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.4"></A>
<H3>1.4.4. remove_edge</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>remove_edge</TT></FONT> has three invokations: by <FONT COLOR=#000033><TT>edge_descriptor</TT></FONT>,
by two <FONT COLOR=#000033><TT>vertex_descriptors</TT></FONT>, or by <FONT COLOR=#000033><TT>out_edge_iterator</TT></FONT>.
All are functionally equivalent.

<P>The <B>Storage Policy</B> will be told of edge removal before and
after the fact.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="16"></A>16. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
remove_edge(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;v,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.will_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boost::remove_edge(u,&nbsp;v,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.did_remove_edge(u,&nbsp;v);<BR>
}<BR>
<BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
remove_edge(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::edge_descriptor&nbsp;e,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;u,v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;boost::source(e,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;boost::target(e,&nbsp;base_g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.will_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boost::remove_edge(e,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.did_remove_edge(u,&nbsp;v);<BR>
}<BR>
<BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
remove_edge(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::out_edge_iterator&nbsp;i,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&amp;&nbsp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Edge&nbsp;e&nbsp;=&nbsp;*i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;u,v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;boost::source(e,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;boost::target(e,&nbsp;base_g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.will_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boost::remove_edge(i,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.did_remove_edge(u,&nbsp;v);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.5"></A>
<H3>1.4.5. remove_out_edge_if</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>remove_out_edge_if</TT></FONT> takes a vertex and a predicate. It iterates
over the out edges of the vertex and removes any of them if
<FONT COLOR=#000033><TT>Predicate(edge)</TT></FONT> resolves to <FONT COLOR=#000033><TT>true</TT></FONT>. Again, the <B>Storage Policy</B>
will be told before and after each edge removal.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="17"></A>17. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase,&nbsp;class&nbsp;Predicate&gt;<BR>
inline&nbsp;void<BR>
remove_out_edge_if(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&nbsp;predicate,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::out_edge_iterator&nbsp;iterator;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Edge&gt;&nbsp;to_remove;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;ei,&nbsp;ei_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(ei,&nbsp;ei_end)&nbsp;=&nbsp;boost::out_edges(u,&nbsp;base_g);&nbsp;ei&nbsp;!=&nbsp;ei_end;&nbsp;++ei)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(predicate(*ei))&nbsp;to_remove.push_back(*ei);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(typename&nbsp;graph_traits::edges_size_type&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;to_remove.size();&nbsp;i++)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;boost::target(to_remove[i],&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.will_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::remove_edge(to_remove[i],&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.did_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.6"></A>
<H3>1.4.6. remove_in_edge_if</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This method is overloaded from the boost such that it will be impossible
to call on an <FONT COLOR=#000033><TT>SEGraph</TT></FONT>. Since our graphs are directed, the concept of
"in edges" doesn't really exist.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="18"></A>18. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase,&nbsp;class&nbsp;Predicate&gt;<BR>
inline&nbsp;void<BR>
remove_in_edge_if(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate,&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&amp;)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DoNotUseThisMethodException&nbsp;{};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;DoNotUseThisMethodException();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.7"></A>
<H3>1.4.7. remove_edge_if</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This method removes all edges in the graph that match <FONT COLOR=#000033><TT>Predicate</TT></FONT>.
The <B>Storage Policy</B> will be notified before and after each edge
removal.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="19"></A>19. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase,&nbsp;class&nbsp;Predicate&gt;<BR>
inline&nbsp;void<BR>
remove_edge_if(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Predicate&nbsp;predicate,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_iterator&nbsp;iterator;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Edge&gt;&nbsp;to_remove;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;ei,&nbsp;ei_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(ei,&nbsp;ei_end)&nbsp;=&nbsp;boost::edges(base_g);&nbsp;ei&nbsp;!=&nbsp;ei_end;&nbsp;++ei)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(predicate(*ei))&nbsp;to_remove.push_back(*ei);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(typename&nbsp;graph_traits::edges_size_type&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;to_remove.size();&nbsp;i++)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;u,&nbsp;v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u&nbsp;=&nbsp;boost::source(to_remove[i],&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;boost::target(to_remove[i],&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.will_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::remove_edge(to_remove[i],&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.did_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.8"></A>
<H3>1.4.8. clear_vertex</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This method will clear all edges to and from the given vertex from
the graph. The <B>Storage Policy</B> will be notified before and after
the vertex is cleared.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="20"></A>20. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
clear_vertex(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.will_clear_vertex(u);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boost::clear_vertex(u,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.did_clear_vertex(u);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.9"></A>
<H3>1.4.9. clear_out_edges</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This method takes a vertex and clears all the edges coming out
of the vertex. The <B>Storage Policy</B> will be notified before and after
each edge removal.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="21"></A>21. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
clear_out_edges(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::vertex_descriptor&nbsp;Vertex;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;Edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::out_edge_iterator&nbsp;iterator;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;ei,&nbsp;ei_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boost::tie(ei,&nbsp;ei_end)&nbsp;=&nbsp;boost::out_edges(u,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Edge&gt;&nbsp;to_remove(ei,&nbsp;ei_end);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(typename&nbsp;graph_traits::edges_size_type&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;to_remove.size();&nbsp;i++)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vertex&nbsp;v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;boost::target(to_remove[i],&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.will_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boost::remove_edge(to_remove[i],&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.did_remove_edge(u,&nbsp;v);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.10"></A>
<H3>1.4.10. clear_in_edges</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This method should never be called and is overloaded just to make sure.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="22"></A>22. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
clear_in_edges(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&amp;)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DoNotUseThisMethodException&nbsp;{};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;DoNotUseThisMethodException();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.11"></A>
<H3>1.4.11. remove_vertex</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>remove_vertex</TT></FONT> will remove a vertex from the graph. The <B>Storage Policy</B>
will be notified before and after the vertex removal.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="23"></A>23. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
remove_vertex(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;storage_traits&lt;StoragePolicySelector&gt;::vertex_properties_type&nbsp;vp&nbsp;=&nbsp;g[u];<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.will_remove_vertex(u,&nbsp;vp);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;boost::remove_vertex(u,&nbsp;base_g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;g.did_remove_vertex(vp);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.12"></A>
<H3>1.4.12. merge_vertices</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>merge_vertices</TT></FONT> will merge the second vertex into the first. The second
vertex will no longer exist, and all the edges will be copied over to
the first vertex.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="24"></A>24. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;void<BR>
merge_vertices(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;v,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::base_graph_type&nbsp;base_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;base_type&amp;&nbsp;base_g&nbsp;=&nbsp;static_cast&lt;base_type&amp;&gt;(g);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;step&nbsp;one:&nbsp;take&nbsp;all&nbsp;the&nbsp;edges&nbsp;from&nbsp;#2&nbsp;and&nbsp;run&nbsp;into&nbsp;#1&nbsp;(this&nbsp;is&nbsp;slow...)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;graph_traits::edge_iterator&nbsp;ei,&nbsp;ei_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(ei,&nbsp;ei_end)&nbsp;=&nbsp;edges(g);&nbsp;ei&nbsp;!=&nbsp;ei_end;&nbsp;++ei)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(source(*ei,&nbsp;g)&nbsp;==&nbsp;v&nbsp;||&nbsp;target(*ei,&nbsp;g)&nbsp;==&nbsp;v)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;copy&nbsp;the&nbsp;edge&nbsp;to&nbsp;u<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;graph_traits::edge_properties_type&nbsp;&amp;ep&nbsp;=&nbsp;g[*ei],&nbsp;nep;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nep.strength&nbsp;=&nbsp;ep.strength;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(source(*ei,&nbsp;g)&nbsp;==&nbsp;v)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_edge(u,&nbsp;target(*ei,&nbsp;g),&nbsp;nep,&nbsp;g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_edge(source(*ei,&nbsp;g),&nbsp;u,&nbsp;nep,&nbsp;g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;now&nbsp;remove&nbsp;the&nbsp;old&nbsp;vertex<BR>
&nbsp;&nbsp;&nbsp;&nbsp;remove_vertex(v,&nbsp;g);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.13"></A>
<H3>1.4.13. either_edge</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>either_edge</TT></FONT> does not exist in <B>BOOST</B> but is provided here for
convenience. This method takes two vertices: <FONT COLOR=#000033><TT>u</TT></FONT> and <FONT COLOR=#000033><TT>v</TT></FONT> and returns
a <FONT COLOR=#000033><TT>std::pair&lt;edge_descriptor,bool&gt;</TT></FONT>. <FONT COLOR=#000033><TT>bool</TT></FONT> will be <FONT COLOR=#000033><TT>true</TT></FONT> if
an edge from either <FONT COLOR=#000033><TT>u-&gt;v</TT></FONT> or <FONT COLOR=#000033><TT>v-&gt;u</TT></FONT> is found, and <FONT COLOR=#000033><TT>false</TT></FONT> otherwise.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="25"></A>25. <A HREF="#31">non-member functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector,&nbsp;class&nbsp;SEBase&gt;<BR>
inline&nbsp;std::pair&lt;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::edge_descriptor,&nbsp;bool&gt;<BR>
either_edge(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;u,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;::vertex_descriptor&nbsp;v,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SEGraph&lt;StoragePolicySelector,&nbsp;SEBase&gt;&nbsp;&amp;g)<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;se_graph_traits&lt;StoragePolicySelector&gt;&nbsp;graph_traits;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;graph_traits::edge_descriptor&nbsp;edge_desc;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::pair&lt;edge_desc,&nbsp;bool&gt;&nbsp;edge_exists&nbsp;=&nbsp;edge(u,&nbsp;v,&nbsp;g);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(edge_exists.second)&nbsp;return&nbsp;edge_exists;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;edge(v,&nbsp;u,&nbsp;g);<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#13">13</A>, <A HREF="#14">14</A>, <A HREF="#15">15</A>, <A HREF="#16">16</A>, <A HREF="#17">17</A>, <A HREF="#18">18</A>, <A HREF="#19">19</A>, <A HREF="#20">20</A>, <A HREF="#21">21</A>, <A HREF="#22">22</A>, <A HREF="#23">23</A>, <A HREF="#24">24</A> and <A HREF="#25">25</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.4.14"></A>
<H3>1.4.14. ostream output</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This is defined to allow an <FONT COLOR=#000033><TT>SEGraph</TT></FONT> to be output to a <FONT COLOR=#000033><TT>std::ostream</TT></FONT>.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="26"></A>26. <A HREF="#31">global functions</A>+={<FONT COLOR=#000033><TT><BR>
template&lt;class&nbsp;S,&nbsp;class&nbsp;B&gt;<BR>
std::ostream&nbsp;&amp;&nbsp;operator&lt;&lt;(std::ostream&nbsp;&amp;o,&nbsp;const&nbsp;SEGraph&lt;S,B&gt;&nbsp;&amp;g)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&lt;&lt;&nbsp;"graph:&nbsp;"&nbsp;&lt;&lt;&nbsp;get_property(g,&nbsp;graph_name)&nbsp;&lt;&lt;&nbsp;"&nbsp;(v:"&nbsp;&lt;&lt;&nbsp;num_vertices(g)&nbsp;&lt;&lt;&nbsp;"&nbsp;e:"&nbsp;&lt;&lt;&nbsp;num_edges(g)&nbsp;&lt;&lt;&nbsp;")"&nbsp;&lt;&lt;&nbsp;std::endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;S&gt;::vertex_iterator&nbsp;vi,&nbsp;vi_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(vi,&nbsp;vi_end)&nbsp;=&nbsp;vertices(g);&nbsp;vi&nbsp;!=&nbsp;vi_end;&nbsp;++vi)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;S&gt;::adjacency_iterator&nbsp;ai,&nbsp;ai_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&lt;&lt;&nbsp;g[*vi].content&nbsp;&lt;&lt;&nbsp;"("&nbsp;&lt;&lt;&nbsp;g[*vi].type_major&nbsp;&lt;&lt;&nbsp;"):&nbsp;";<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(ai,&nbsp;ai_end)&nbsp;=&nbsp;adjacent_vertices(*vi,&nbsp;g);&nbsp;ai&nbsp;!=&nbsp;ai_end;&nbsp;++ai)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&lt;&lt;&nbsp;g[*ai].content&nbsp;&lt;&lt;&nbsp;"("&nbsp;&lt;&lt;&nbsp;g[*ai].type_major&nbsp;&lt;&lt;&nbsp;")&nbsp;";<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o&nbsp;&lt;&lt;&nbsp;std::endl;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;o;<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#26">26</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.5"></A>
<H2>1.5. Managing Indices</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>You can use the following class to manage index files. It allows manipulation of
collections without creating an <FONT COLOR=#000033><TT>SEGraph</TT></FONT> object tied to a collection.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="27"></A>27. <A HREF="#31">index manager</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;StoragePolicySelector&gt;<BR>
class&nbsp;index_manager&nbsp;:&nbsp;public&nbsp;StoragePolicy&lt;StoragePolicySelector,&nbsp;empty_class&gt;<BR>
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;StoragePolicy&lt;StoragePolicySelector,&nbsp;empty_class&gt;&nbsp;SEBase;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;public:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::string&gt;&nbsp;list_collections()&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;std::string&gt;&nbsp;collections;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SEBase::get_collections_list(back_inserter(collections));<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;collections;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;rename_collection(std::string&nbsp;oldname,&nbsp;std::string&nbsp;newname)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SEBase::rename_collection(oldname,&nbsp;newname);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;remove_collection(std::string&nbsp;name)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SEBase::remove_collection(name);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
};&nbsp;//&nbsp;index_manager<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#27">27</A> and <A HREF="#28">28</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
 
And for backwards compatibility:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="28"></A>28. <A HREF="#31">index manager</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;S&gt;<BR>
class&nbsp;StorageInfoQuery&nbsp;:&nbsp;public&nbsp;index_manager&lt;S&gt;&nbsp;{};<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#27">27</A> and <A HREF="#28">28</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.6"></A>
<H2>1.6. Using Smart Pointers</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>If smart pointers are to be used with the <FONT COLOR=#000033><TT>SEGraph</TT></FONT> class, a
convenience reference counter variable has been included in
the public scope and is automatically initialized to <FONT COLOR=#000033><TT>0</TT></FONT>
on construction.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="29"></A>29. <A HREF="#2">SEGraph public scope</A>+={<FONT COLOR=#000033><TT>unsigned&nbsp;int&nbsp;__refcount;</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#7">7</A>, <A HREF="#8">8</A>, <A HREF="#10">10</A>, <A HREF="#11">11</A>, <A HREF="#12">12</A> and <A HREF="#29">29</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#2">2</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Furthermore, if using <B>BOOST</B>'s <FONT COLOR=#000033><TT>intrusive_ptr</TT></FONT> class, the
helper functions necessary to do so are defined here:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="30"></A>30. <A HREF="#31">BOOST intrusive_ptr functions</A>={<FONT COLOR=#000033><TT><BR>
namespace&nbsp;boost&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;S,&nbsp;class&nbsp;B&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;inline&nbsp;void&nbsp;intrusive_ptr_add_ref(SEGraph&lt;S,B&gt;&nbsp;*&nbsp;p)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++(p-&gt;__refcount);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;S,&nbsp;class&nbsp;B&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;inline&nbsp;void&nbsp;intrusive_ptr_release(SEGraph&lt;S,B&gt;&nbsp;*&nbsp;p)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(--(p-&gt;__refcount)&nbsp;==&nbsp;0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;p;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}&nbsp;//&nbsp;namespace&nbsp;boost<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#31">31</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.7"></A>
<H2>1.7. The File: semantic.hpp</H2>
<FONT COLOR=#CC0033>
<P><A NAME="31"></A><B>31. File:</B> semantic/semantic.hpp={<FONT COLOR=#000033><TT><BR>
#ifndef&nbsp;_SEMANTIC_HPP_<BR>
#define&nbsp;_SEMANTIC_HPP_<BR>
<BR>
</TT>
<A HREF="#1">includes</A><TT><BR>
<BR>
using&nbsp;std::string;<BR>
using&nbsp;std::vector;<BR>
using&nbsp;std::set;<BR>
using&nbsp;namespace&nbsp;boost;<BR>
using&nbsp;namespace&nbsp;semantic;<BR>
<BR>
namespace&nbsp;semantic&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#2">SEGraph</A><TT><BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#27">index manager</A><TT><BR>
<BR>
}&nbsp;//&nbsp;namespace&nbsp;semantic<BR>
<BR>
namespace&nbsp;boost&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#13">non-member functions</A><TT><BR>
}&nbsp;//&nbsp;namespace&nbsp;boost<BR>
<BR>
</TT>
<A HREF="#26">global functions</A><TT><BR>
<BR>
</TT>
<A HREF="#30">BOOST intrusive_ptr functions</A><TT><BR>
<BR>
#endif&nbsp;/*&nbsp;_SEMANTIC_HPP_&nbsp;*/<BR>
<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is attached to an output file.</FONT>
<P>
<HR SIZE=4 NOSHADE>
<CENTER><B>End Of File</B></CENTER>
<HR SIZE=4 NOSHADE>
</BODY>

<!----------------------------------------------------------------------------->
<!--                   END OF AUTOMATICALLY GENERATED HTML FILE              -->
<!----------------------------------------------------------------------------->
</HTML>
