<HTML>

<!----------------------------------------------------------------------------->
<!--                  START OF AUTOMATICALLY GENERATED HTML FILE             -->
<!----------------------------------------------------------------------------->
<!--                                                                         -->
<!-- This HTML file was generated by the FunnelWeb literate programming      -->
<!-- preprocessor. You can display this file using popular web browsers      -->
<!-- such as Netscape Navigator and Microsoft Internet Explorer.             -->
<!--                                                                         -->
<!-- FunnelWeb is a preprocessor that allows programmers to weave programs   -->
<!-- and their documentation together in a single document. The FunnelWeb    -->
<!-- program analyses such documents producing both program files and        -->
<!-- typeset documentation such as this HTML file.                           -->
<!--                                                                         -->
<!-- FunnelWeb was created by Ross N. Williams (www.ross.net) and is         -->
<!-- available free of charge under a GNU General Public Licence.            -->
<!-- The FunnelWeb website can be found at http://www.ross.net/funnelweb/    -->
<!--                                                                         -->
<!----------------------------------------------------------------------------->

<HEAD>

<TITLE>Package weighting</TITLE>

<STYLE TYPE="text/css">
<!--
A {text-decoration: none}
H1 { font-family: sans-serif; font-size: large }
H2 { font-family: sans-serif; font-size: medium; font-weight: bold }
H3 { font-family: sans-serif; font-size: medium }
H4 { font-family: sans-serif; font-size: small }
H5 { font-family: sans-serif; font-size: small }
// -->
</STYLE>

</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#CC0033 VLINK=#CC0033 ALINK=#CC0000>

<BR>

<BR>

<BR>

<BR>

<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=7>Semantic Engine C++ API</FONT></DIV>
</TD></TR></TABLE><BR>
<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=5>Weighting Algorithms</FONT></DIV>
</TD></TR></TABLE><BR>
<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=4>By Gabriel Schine</FONT></DIV>
</TD></TR></TABLE><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>

This file describes the algorithms for determining the
weight (or similarity) between nodes in the Semantic Engine.

<P></TD></TR></TABLE>
<BR>


<A HREF="#sec_1">1. Weighting Algorithms</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.1">1.1. Two Ways of Invoking the Algorithms</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.1.1">1.1.1. Method 1: Edges not in Graph</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.1.2">1.1.2. Method 2: Edges are in Graph</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.2">1.2. The Algorithms</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.2.1">1.2.1. TF: Term Frequency</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.2.2">1.2.2. IDF: Inverse Document Frequency</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.2.3">1.2.3. LG: Local/Global combination</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.2.4">1.2.4. None: No Weighting</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3">1.3. The Code Files</A><BR>

<P><HR SIZE=4 NOSHADE><P><A NAME="sec_1"></A>
<H1>1. Weighting Algorithms</H1>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The <B>Weighting Algorithms</B> available to the <B>Semantic Engine</B> play a very
important role, from how a subgraph is extracted from storage to how a ranking
operation affects the vertices.

<P>Using the following data, a <B>Weighting Algorithm</B> must derive a single weight
for an edge (usually in the form of a <FONT COLOR=#000033><TT>double</TT></FONT>):

<P>* the total number of nodes of given types in the stored graph (the <FONT COLOR=#000033><TT>node_count</TT></FONT>),

<P>* the "strength" of the edge (ex, how many times the term appears in the document)

<P>* the in and out-degrees of the edge (ex, how many edges are coming out of our source
or target vertices)

<P>The algorithm may use any other information available through the <FONT COLOR=#000033><TT>SESubgraph</TT></FONT> class.

<P></TD></TR></TABLE>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.1"></A>
<H2>1.1. Two Ways of Invoking the Algorithms</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>There are two ways of invoking the algorithms, which are there for two different purposes.
A <B>Subgraph Algorithm</B> might need to know the weights of edges before they are actually
put into the <B>BOOST</B><FONT COLOR=#000033><TT>adjacency_list</TT></FONT>. Then, once the graph is complete, a user
may want to know the weights of all the edges in the graph (or a subset of them).

<P></TD></TR></TABLE>
<P><HR SIZE=3><P><A NAME="sec_1.1.1"></A>
<H3>1.1.1. Method 1: Edges not in Graph</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Method one has an interface defined as:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="1"></A>1. <A HREF="#13">weight edges not in graph interface</A>[<B>M</B>]={<FONT COLOR=#000033><TT><BR>
template&lt;class&nbsp;Vertex,&nbsp;class&nbsp;NeighborList,&nbsp;class&nbsp;Graph,&nbsp;class&nbsp;WeightMap&gt;<BR>
void&nbsp;apply_weights(Vertex&nbsp;u,&nbsp;const&nbsp;NeighborList&nbsp;&amp;nlist,&nbsp;Graph&nbsp;&amp;g,&nbsp;WeightMap&nbsp;w)<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definitions <A HREF="#13">13</A> and <A HREF="#14">14</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>In the above, <FONT COLOR=#000033><TT>NeighborList</TT></FONT> is a <FONT COLOR=#000033><TT>std::vector</TT></FONT> of
<FONT COLOR=#000033><TT>std::pair&lt;edge_properties_type, vertex_properties_type&gt;</TT></FONT>, defining the edge properties
vertex properties of the target node of the edge for each edge. For this reason, the output
placed in the <FONT COLOR=#000033><TT>WeightMap</TT></FONT> (which is a <B>BOOST</B> property map) is keyed by the ID (<FONT COLOR=#000033><TT>se_graph_traits&lt;Graph&gt;::vertex_id_type</TT></FONT>)
of the target node of the edge.

<P></TD></TR></TABLE>
<P><HR SIZE=3><P><A NAME="sec_1.1.2"></A>
<H3>1.1.2. Method 2: Edges are in Graph</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Method two is defined as:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="2"></A>2. <A HREF="#13">weight edges in graph interface</A>[<B>M</B>]={<FONT COLOR=#000033><TT><BR>
template&lt;class&nbsp;Vertex,&nbsp;class&nbsp;Graph,&nbsp;class&nbsp;WeightMap&gt;<BR>
void&nbsp;apply_weights(Vertex&nbsp;u,&nbsp;Graph&nbsp;&amp;g,&nbsp;WeightMap&nbsp;w)<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definitions <A HREF="#13">13</A> and <A HREF="#14">14</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This interface is similar to Method 1, but it gets its edge information directly from the
graph using <B>BOOST</B> graph library calls. The <FONT COLOR=#000033><TT>WeightMap</TT></FONT> is keyed by edge
(<FONT COLOR=#000033><TT>se_graph_traits&lt;Graph&gt;::edge_descriptor</TT></FONT>).

<P></TD></TR></TABLE>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.2"></A>
<H2>1.2. The Algorithms</H2>
<P><HR SIZE=3><P><A NAME="sec_1.2.1"></A>
<H3>1.2.1. TF: Term Frequency</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Term frequency uses the number of times a term appears in a document to describe the weight
of the edge connecting the two.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="3"></A>3. <A HREF="#10">TF in graph</A>={<FONT COLOR=#000033><TT>put(w,&nbsp;*ei,&nbsp;g[*ei].strength);</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#10">10</A>.</FONT><BR>
<FONT COLOR=#CC0033>
<P><A NAME="4"></A>4. <A HREF="#10">TF not in graph</A>={<FONT COLOR=#000033><TT>put(w,&nbsp;g.get_vertex_id((*ei).second),&nbsp;(*ei).first.strength);</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#10">10</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.2.2"></A>
<H3>1.2.2. IDF: Inverse Document Frequency</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Inverse document frequency takes a different approach. It intends to penalize any node
(and thus the edges going <B>to</B> it) that is too well connected in the graph. The
actual formula is <FONT COLOR=#000033><TT>w = log(1 + count/degree)</TT></FONT> where <FONT COLOR=#000033><TT>count</TT></FONT> is the total number of
nodes and <FONT COLOR=#000033><TT>degree</TT></FONT> is the degree of the target node. Since the <B>Semantic Engine</B>
uses a bipartite graph and stores node types with nodes, the <FONT COLOR=#000033><TT>count</TT></FONT> is the number
of nodes of the same type as the <B>source</B> node type, and the <FONT COLOR=#000033><TT>degree</TT></FONT> is the
degree of the target node, but only those edges pointing at nodes of the same type
as the source node.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="5"></A>5. <A HREF="#11">IDF in graph</A>={<FONT COLOR=#000033><TT>put(w,&nbsp;*ei,&nbsp;log(1+count/(g[*ei].to_degree)));</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#11">11</A>.</FONT><BR>
<FONT COLOR=#CC0033>
<P><A NAME="6"></A>6. <A HREF="#11">IDF not in graph</A>={<FONT COLOR=#000033><TT>put(w,&nbsp;g.get_vertex_id((*ei).second),&nbsp;log(1+count/((*ei).first.to_degree)));</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#11">11</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>Since we need to get the node counts from the graph, we need this code:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="7"></A>7. <A HREF="#11">IDF get node counts</A>={<FONT COLOR=#000033><TT><BR>
typename&nbsp;se_graph_traits&lt;typename&nbsp;Graph::storage_policy_selector&gt;::vertices_size_type&nbsp;count<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;g.get_vertex_count_of_type(g[u].type_major);</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#11">11</A>.</FONT><BR>
<P><HR SIZE=3><P><A NAME="sec_1.2.3"></A>
<H3>1.2.3. LG: Local/Global combination</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>LG weighting stands for "Local and Global" weighting. This is just a utility class
that takes two other <B>Weighting Algorithms</B> and multiplies them together.

<P></TD></TR></TABLE>
<P><HR SIZE=3><P><A NAME="sec_1.2.4"></A>
<H3>1.2.4. None: No Weighting</H3>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The <B>Semantic Engine</B> also offers a "No Weighting" class, which just sets any weight asked
for to "1".

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="8"></A>8. <A HREF="#12">None in graph</A>={<FONT COLOR=#000033><TT>put(w,&nbsp;*ei,&nbsp;1);</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#12">12</A>.</FONT><BR>
<FONT COLOR=#CC0033>
<P><A NAME="9"></A>9. <A HREF="#12">None not in graph</A>={<FONT COLOR=#000033><TT>put(w,&nbsp;g.get_vertex_id((*ei).second),&nbsp;1);</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#12">12</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.3"></A>
<H2>1.3. The Code Files</H2>
<FONT COLOR=#CC0033>
<P><A NAME="10"></A><B>10. File:</B> semantic/weighting/tf.hpp={<FONT COLOR=#000033><TT><BR>
</TT>
<A HREF="#13">basic weighting header file</A><FONT COLOR=#CC0033>(</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><TT>_TF_WEIGHTING_HPP_</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><TT>TFWeighting</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><FONT COLOR=#CC0033>"</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#3">TF in graph</A><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><FONT COLOR=#CC0033>"</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#4">TF not in graph</A><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>)</FONT><TT><BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is attached to an output file.</FONT>
<FONT COLOR=#CC0033>
<P><A NAME="11"></A><B>11. File:</B> semantic/weighting/idf.hpp={<FONT COLOR=#000033><TT><BR>
</TT>
<A HREF="#13">basic weighting header file</A><FONT COLOR=#CC0033>(</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><TT>_IDF_WEIGHTING_HPP_</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><TT>IDFWeighting</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><FONT COLOR=#CC0033>"</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#5">IDF in graph</A><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><FONT COLOR=#CC0033>"</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#6">IDF not in graph</A><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><FONT COLOR=#CC0033>"</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#7">IDF get node counts</A><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>)</FONT><TT><BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is attached to an output file.</FONT>
<FONT COLOR=#CC0033>
<P><A NAME="12"></A><B>12. File:</B> semantic/weighting/none.hpp={<FONT COLOR=#000033><TT><BR>
</TT>
<A HREF="#13">basic weighting header file</A><FONT COLOR=#CC0033>(</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><TT>_NO_WEIGHTING_HPP_</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><TT>NoWeighting</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><FONT COLOR=#CC0033>"</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#8">None in graph</A><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><FONT COLOR=#CC0033>"</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#9">None not in graph</A><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>,</FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>"</FONT><FONT COLOR=#CC0033>)</FONT><TT><BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is attached to an output file.</FONT>
<FONT COLOR=#CC0033>
<P><A NAME="13"></A>13. <A HREF="#10">basic weighting header file</A>(<B>5</B>)[<B>M</B>]={<FONT COLOR=#000033><TT><BR>
#ifndef&nbsp;</TT>
<FONT COLOR=#CC0033><B>1</B></FONT><TT><BR>
#define&nbsp;</TT>
<FONT COLOR=#CC0033><B>1</B></FONT><TT><BR>
<BR>
#include&nbsp;&lt;math.h&gt;<BR>
<BR>
namespace&nbsp;semantic&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;</TT>
<FONT COLOR=#CC0033><B>2</B></FONT><TT>&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;double&nbsp;weight_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#1">weight edges not in graph interface</A><TT>{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;NeighborList::const_iterator&nbsp;iterator;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033><B>5</B></FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;ei;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ei&nbsp;=&nbsp;nlist.begin();&nbsp;ei&nbsp;!=&nbsp;nlist.end();&nbsp;++ei)&nbsp;{&nbsp;</TT>
<FONT COLOR=#CC0033><B>4</B></FONT><TT>&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#2">weight edges in graph interface</A><TT>{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;se_graph_traits&lt;Graph&gt;::out_edge_iterator&nbsp;iterator;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;se_graph_traits&lt;Graph&gt;::edge_descriptor&nbsp;edge;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function_requires&lt;&nbsp;WritablePropertyMapConcept&lt;WeightMap,&nbsp;edge&gt;&nbsp;&gt;();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<FONT COLOR=#CC0033><B>5</B></FONT><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;ei,&nbsp;ei_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(ei,&nbsp;ei_end)&nbsp;=&nbsp;out_edges(u,&nbsp;g);&nbsp;ei&nbsp;!=&nbsp;ei_end;&nbsp;++ei)&nbsp;{&nbsp;</TT>
<FONT COLOR=#CC0033><B>3</B></FONT><TT>&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
}&nbsp;//&nbsp;namespace&nbsp;semantic<BR>
<BR>
#endif&nbsp;//&nbsp;</TT>
<FONT COLOR=#CC0033><B>1</B></FONT><TT><BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definitions <A HREF="#10">10</A>, <A HREF="#11">11</A> and <A HREF="#12">12</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>LG weighting gets its own file definition due to complexity.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="14"></A><B>14. File:</B> semantic/weighting/lg.hpp={<FONT COLOR=#000033><TT><BR>
#ifndef&nbsp;_LG_WEIGHTING_HPP_<BR>
#define&nbsp;_LG_WEIGHTING_HPP_<BR>
<BR>
#include&nbsp;&lt;map&gt;<BR>
#include&nbsp;&lt;semantic/utility.hpp&gt;<BR>
#include&nbsp;&lt;boost/graph/properties.hpp&gt;<BR>
<BR>
namespace&nbsp;semantic&nbsp;{<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;Local,&nbsp;class&nbsp;Global,&nbsp;typename&nbsp;WeightType&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;LGWeighting&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;Local::weight_type&nbsp;local_weight_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;Global::weight_type&nbsp;global_weight_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;WeightType&nbsp;weight_type;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#1">weight edges not in graph interface</A><TT>{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;NeighborList::const_iterator&nbsp;iterator;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;start&nbsp;by&nbsp;calculating&nbsp;the&nbsp;local&nbsp;and&nbsp;global&nbsp;weights,&nbsp;respectively<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;property_traits&lt;WeightMap&gt;::key_type&nbsp;key_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;std::map&lt;key_type,&nbsp;typename&nbsp;Local::weight_type&gt;&nbsp;my_lmap;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;std::map&lt;key_type,&nbsp;typename&nbsp;Global::weight_type&gt;&nbsp;my_gmap;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_lmap&nbsp;lw;&nbsp;boost::associative_property_map&lt;my_lmap&gt;&nbsp;lmap(lw);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_gmap&nbsp;gw;&nbsp;boost::associative_property_map&lt;my_gmap&gt;&nbsp;gmap(gw);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local.apply_weights(u,&nbsp;nlist,&nbsp;g,&nbsp;lmap);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.apply_weights(u,&nbsp;nlist,&nbsp;g,&nbsp;gmap);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;ei;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(ei&nbsp;=&nbsp;nlist.begin();&nbsp;ei&nbsp;!=&nbsp;nlist.end();&nbsp;++ei)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;se_graph_traits&lt;typename&nbsp;Graph::storage_policy_type&gt;::vertex_id_type&nbsp;id&nbsp;=&nbsp;g.get_vertex_id((*ei).second);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put(w,&nbsp;id,&nbsp;get(lmap,&nbsp;id)&nbsp;*&nbsp;get(gmap,&nbsp;id));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#2">weight edges in graph interface</A><TT>{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;se_graph_traits&lt;Graph&gt;::out_edge_iterator&nbsp;iterator;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;se_graph_traits&lt;Graph&gt;::edge_descriptor&nbsp;edge;<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function_requires&lt;&nbsp;WritablePropertyMapConcept&lt;WeightMap,&nbsp;edge&gt;&nbsp;&gt;();<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;start&nbsp;by&nbsp;calculating&nbsp;the&nbsp;local&nbsp;and&nbsp;global&nbsp;weights,&nbsp;respectively<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;property_traits&lt;WeightMap&gt;::key_type&nbsp;key_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;std::map&lt;edge,&nbsp;typename&nbsp;Local::weight_type&gt;&nbsp;my_lmap;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;std::map&lt;edge,&nbsp;typename&nbsp;Global::weight_type&gt;&nbsp;my_gmap;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_lmap&nbsp;lw;&nbsp;boost::associative_property_map&lt;my_lmap&gt;&nbsp;lmap(lw);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my_gmap&nbsp;gw;&nbsp;boost::associative_property_map&lt;my_gmap&gt;&nbsp;gmap(gw);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local.apply_weights(u,&nbsp;g,&nbsp;lmap);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.apply_weights(u,&nbsp;g,&nbsp;gmap);<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator&nbsp;ei,&nbsp;ei_end;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(boost::tie(ei,&nbsp;ei_end)&nbsp;=&nbsp;out_edges(u,&nbsp;g);&nbsp;ei&nbsp;!=&nbsp;ei_end;&nbsp;++ei)&nbsp;put(w,&nbsp;*ei,&nbsp;lw[*ei]&nbsp;*&nbsp;gw[*ei]);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Local&nbsp;local;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Global&nbsp;global;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
<BR>
}&nbsp;//&nbsp;namespace&nbsp;semantic<BR>
<BR>
#endif<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is attached to an output file.</FONT>
<P>
<HR SIZE=4 NOSHADE>
<CENTER><B>End Of File</B></CENTER>
<HR SIZE=4 NOSHADE>
</BODY>

<!----------------------------------------------------------------------------->
<!--                   END OF AUTOMATICALLY GENERATED HTML FILE              -->
<!----------------------------------------------------------------------------->
</HTML>
