<HTML>

<!----------------------------------------------------------------------------->
<!--                  START OF AUTOMATICALLY GENERATED HTML FILE             -->
<!----------------------------------------------------------------------------->
<!--                                                                         -->
<!-- This HTML file was generated by the FunnelWeb literate programming      -->
<!-- preprocessor. You can display this file using popular web browsers      -->
<!-- such as Netscape Navigator and Microsoft Internet Explorer.             -->
<!--                                                                         -->
<!-- FunnelWeb is a preprocessor that allows programmers to weave programs   -->
<!-- and their documentation together in a single document. The FunnelWeb    -->
<!-- program analyses such documents producing both program files and        -->
<!-- typeset documentation such as this HTML file.                           -->
<!--                                                                         -->
<!-- FunnelWeb was created by Ross N. Williams (www.ross.net) and is         -->
<!-- available free of charge under a GNU General Public Licence.            -->
<!-- The FunnelWeb website can be found at http://www.ross.net/funnelweb/    -->
<!--                                                                         -->
<!----------------------------------------------------------------------------->

<HEAD>

<TITLE>Package utility</TITLE>

<STYLE TYPE="text/css">
<!--
A {text-decoration: none}
H1 { font-family: sans-serif; font-size: large }
H2 { font-family: sans-serif; font-size: medium; font-weight: bold }
H3 { font-family: sans-serif; font-size: medium }
H4 { font-family: sans-serif; font-size: small }
H5 { font-family: sans-serif; font-size: small }
// -->
</STYLE>

</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#CC0033 VLINK=#CC0033 ALINK=#CC0000>

<BR>

<BR>

<BR>

<BR>

<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=7>Semantic Engine C++ API</FONT></DIV>
</TD></TR></TABLE><BR>
<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=5>Utility Functions</FONT></DIV>
</TD></TR></TABLE><BR>
<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<DIV STYLE="font-family: sans-serif" ALIGN=center><FONT SIZE=4>By Gabriel Schine</FONT></DIV>
</TD></TR></TABLE><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>

This file describes the utility functions and classes
used in the Semantic Engine.

<P></TD></TR></TABLE>
<BR>


<A HREF="#sec_1">1. Utility Functions and Classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.1">1.1. Empty Class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.2">1.2. Type-Independent abs and max</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.3">1.3. String Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.4">1.4. Transform Iterators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.5">1.5. Numerical Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#sec_1.6">1.6. Maps Namespace</A><BR>

<P><HR SIZE=4 NOSHADE><P><A NAME="sec_1"></A>
<H1>1. Utility Functions and Classes</H1>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>This file contains a number of utility functions and classes that
are used throughout the <B>Semantic Engine</B>. Each has its own
section below.

<P></TD></TR></TABLE>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.1"></A>
<H2>1.1. Empty Class</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>An empty class. This can be thought of as the "NULL" type.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="1"></A>1. <A HREF="#13">utility classes</A>+={<FONT COLOR=#000033><TT>class&nbsp;empty_class&nbsp;{};</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#1">1</A> and <A HREF="#7">7</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.2"></A>
<H2>1.2. Type-Independent abs and max</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The following two functions perform what you would expect, but
any type can be passed in.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="2"></A>2. <A HREF="#13">utility functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;class&nbsp;T&gt;<BR>
inline&nbsp;T&nbsp;t_abs(const&nbsp;T&amp;&nbsp;t)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t&nbsp;*&nbsp;(t&lt;0?-1:1);<BR>
}<BR>
<BR>
template&nbsp;&lt;typename&nbsp;T&gt;<BR>
inline&nbsp;T&nbsp;max(const&nbsp;T&amp;&nbsp;one,&nbsp;const&nbsp;T&amp;&nbsp;two)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;one&gt;two?one:two;<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#2">2</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#9">9</A> and <A HREF="#10">10</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.3"></A>
<H2>1.3. String Functions</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The string functions require some includes:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="3"></A>3. <A HREF="#13">includes</A>+={<FONT COLOR=#000033><TT><BR>
#include&nbsp;&lt;string&gt;<BR>
#include&nbsp;&lt;sstream&gt;<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#8">8</A> and <A HREF="#11">11</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>to_string</TT></FONT> takes any type (which can be printed) and converts
it into a <FONT COLOR=#000033><TT>std::string</TT></FONT>.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="4"></A>4. <A HREF="#13">utility functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;typename&nbsp;T&gt;<BR>
inline&nbsp;std::string&nbsp;to_string(T&nbsp;v)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream&nbsp;strm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;strm&nbsp;&lt;&lt;&nbsp;v;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;strm.str();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#2">2</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#9">9</A> and <A HREF="#10">10</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>join</TT></FONT> takes an iterator range and returns a string with all
elements in the range in sequence with glue in between.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="5"></A>5. <A HREF="#13">utility functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;typename&nbsp;Iterator&gt;<BR>
inline&nbsp;std::string&nbsp;join(Iterator&nbsp;i,&nbsp;Iterator&nbsp;i_end,&nbsp;std::string&nbsp;glue)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream&nbsp;strm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;cnt&nbsp;=&nbsp;0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while(i&nbsp;!=&nbsp;i_end)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cnt++&nbsp;&gt;&nbsp;0)&nbsp;strm&nbsp;&lt;&lt;&nbsp;glue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strm&nbsp;&lt;&lt;&nbsp;*i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;strm.str();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#2">2</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#9">9</A> and <A HREF="#10">10</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>unique_join</TT></FONT> does the same thing as <FONT COLOR=#000033><TT>join</TT></FONT> but will withold
printing out the same element twice by using a <FONT COLOR=#000033><TT>std::set</TT></FONT>.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="6"></A>6. <A HREF="#13">utility functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;typename&nbsp;Iterator&gt;<BR>
inline&nbsp;std::string&nbsp;unique_join(Iterator&nbsp;i,&nbsp;Iterator&nbsp;i_end,&nbsp;std::string&nbsp;glue)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::stringstream&nbsp;strm;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;cnt&nbsp;=&nbsp;0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;std::set&lt;typename&nbsp;Iterator::value_type&gt;&nbsp;used;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while(i&nbsp;!=&nbsp;i_end)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(used.count(*i))&nbsp;{++i;&nbsp;continue;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used.insert(*i);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cnt++&nbsp;&gt;&nbsp;0)&nbsp;strm&nbsp;&lt;&lt;&nbsp;glue;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strm&nbsp;&lt;&lt;&nbsp;*i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++i;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;strm.str();<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#2">2</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#9">9</A> and <A HREF="#10">10</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.4"></A>
<H2>1.4. Transform Iterators</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The following two transform iterators take an iterator of <FONT COLOR=#000033><TT>std::pair</TT></FONT>
elements and create a new iterator that will either hand back
the first or second part of the pair. They can be created by
calling the functions <FONT COLOR=#000033><TT>extract_keys()</TT></FONT> or <FONT COLOR=#000033><TT>extract_values()</TT></FONT>,
or the equivalent <FONT COLOR=#000033><TT>extract_first_iterator()</TT></FONT> and 
<FONT COLOR=#000033><TT>extract_second_iterator()</TT></FONT>.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="7"></A>7. <A HREF="#13">utility classes</A>+={<FONT COLOR=#000033><TT><BR>
namespace&nbsp;detail&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;utility&nbsp;class&nbsp;to&nbsp;extract&nbsp;the&nbsp;first&nbsp;part&nbsp;of&nbsp;a&nbsp;pair<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;P&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;extract_first&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;P::first_type&nbsp;result_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;typename&nbsp;P::first_type&nbsp;&amp;&nbsp;operator()(P&nbsp;&amp;p)&nbsp;const&nbsp;{&nbsp;return&nbsp;p.first;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;and&nbsp;for&nbsp;the&nbsp;second<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;P&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;extract_second&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;typename&nbsp;P::second_type&nbsp;result_type;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;typename&nbsp;P::second_type&nbsp;&amp;&nbsp;operator()(P&nbsp;&amp;p)&nbsp;const&nbsp;{&nbsp;return&nbsp;p.second;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
}&nbsp;//&nbsp;namespace&nbsp;detail<BR>
<BR>
template&nbsp;&lt;class&nbsp;I&gt;<BR>
boost::transform_iterator&lt;detail::extract_first&lt;typename&nbsp;I::value_type&gt;,&nbsp;I&gt;&nbsp;extract_first_iterator(I&nbsp;it)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;boost::transform_iterator&lt;detail::extract_first&lt;typename&nbsp;I::value_type&gt;,&nbsp;I&gt;(it,&nbsp;detail::extract_first&lt;typename&nbsp;I::value_type&gt;());<BR>
}<BR>
#define&nbsp;extract_keys(x)&nbsp;(&nbsp;extract_first_iterator(x)&nbsp;)<BR>
<BR>
template&nbsp;&lt;class&nbsp;I&gt;<BR>
boost::transform_iterator&lt;detail::extract_second&lt;typename&nbsp;I::value_type&gt;,&nbsp;I&gt;&nbsp;extract_second_iterator(I&nbsp;it)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;boost::transform_iterator&lt;detail::extract_second&lt;typename&nbsp;I::value_type&gt;,&nbsp;I&gt;(it,&nbsp;detail::extract_second&lt;typename&nbsp;I::value_type&gt;());<BR>
}<BR>
#define&nbsp;extract_values(x)&nbsp;(&nbsp;extract_second_iterator(x)&nbsp;)<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#1">1</A> and <A HREF="#7">7</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>For the above we need some stuff from boost:

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="8"></A>8. <A HREF="#13">includes</A>+={<FONT COLOR=#000033><TT><BR>
#include&nbsp;&lt;boost/iterator/transform_iterator.hpp&gt;<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#8">8</A> and <A HREF="#11">11</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.5"></A>
<H2>1.5. Numerical Functions</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>keep_within_range(num, min, max)</TT></FONT> will set <FONT COLOR=#000033><TT>num</TT></FONT> equal to either <FONT COLOR=#000033><TT>min</TT></FONT> or <FONT COLOR=#000033><TT>max</TT></FONT>
if it does not fall between them.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="9"></A>9. <A HREF="#13">utility functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;typename&nbsp;Num&gt;<BR>
inline&nbsp;void&nbsp;keep_within_range(Num&nbsp;&amp;val,&nbsp;Num&nbsp;min,&nbsp;Num&nbsp;max)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;val&lt;min?min:val&gt;max?max:val;<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#2">2</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#9">9</A> and <A HREF="#10">10</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>
<FONT COLOR=#000033><TT>set_if_greater(compare, num)</TT></FONT> will set <FONT COLOR=#000033><TT>num</TT></FONT> equal to <FONT COLOR=#000033><TT>compare</TT></FONT> if
<FONT COLOR=#000033><TT>compare</TT></FONT> is greater.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="10"></A>10. <A HREF="#13">utility functions</A>+={<FONT COLOR=#000033><TT><BR>
template&nbsp;&lt;typename&nbsp;T&gt;<BR>
inline&nbsp;void&nbsp;set_if_greater(const&nbsp;T&nbsp;&amp;c,&nbsp;T&nbsp;&amp;m)&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;&gt;&nbsp;m)&nbsp;m&nbsp;=&nbsp;c;<BR>
}<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#2">2</A>, <A HREF="#4">4</A>, <A HREF="#5">5</A>, <A HREF="#6">6</A>, <A HREF="#9">9</A> and <A HREF="#10">10</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<P><HR SIZE=2 NOSHADE><P><A NAME="sec_1.6"></A>
<H2>1.6. Maps Namespace</H2>
<P><TABLE CELLSPACING=0 CELLPADDING=0 BORDER=0><TR><TD WIDTH=400>


<P>The maps namespace exists to help with a smooth transition over to <B>TR1</B>,
the proposed addition to the STL standard. These helper <FONT COLOR=#000033><TT>typedef</TT></FONT>s will
choose between <FONT COLOR=#000033><TT>tr1::unordered_map</TT></FONT> types and <FONT COLOR=#000033><TT>std::map</TT></FONT> types, depending
on what is necessary for the user. If <B>TR1</B> is not available, the <FONT COLOR=#000033><TT>std::</TT></FONT>
namespace will always be used.

<P></TD></TR></TABLE>
<FONT COLOR=#CC0033>
<P><A NAME="11"></A>11. <A HREF="#13">includes</A>+={<FONT COLOR=#000033><TT><BR>
#include&nbsp;&lt;map&gt;<BR>
#include&nbsp;&lt;boost/functional/hash.hpp&gt;<BR>
#ifdef&nbsp;HAVE_TR1_UNORDERED_MAP<BR>
#include&nbsp;&lt;tr1/unordered_map&gt;<BR>
#endif<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is defined in definitions <A HREF="#3">3</A>, <A HREF="#8">8</A> and <A HREF="#11">11</A>.</FONT><BR>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<FONT COLOR=#CC0033>
<P><A NAME="12"></A>12. <A HREF="#13">maps namespace</A>={<FONT COLOR=#000033><TT><BR>
namespace&nbsp;maps&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ordered&nbsp;map&nbsp;--&nbsp;will&nbsp;always&nbsp;use&nbsp;STLs&nbsp;std::map&nbsp;or&nbsp;std::multimap<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;Key,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;Data,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Compare&nbsp;=&nbsp;std::less&lt;Key&gt;,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Alloc&nbsp;=&nbsp;std::allocator&lt;std::pair&lt;const&nbsp;Key,&nbsp;Data&gt;&nbsp;&gt;&nbsp;&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;ordered&nbsp;:&nbsp;public&nbsp;std::map&lt;Key,&nbsp;Data,&nbsp;Compare,&nbsp;Alloc&gt;&nbsp;{};<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ordered&nbsp;multi_map<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;Key,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;Data,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Compare&nbsp;=&nbsp;std::less&lt;Key&gt;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Alloc&nbsp;=&nbsp;std::allocator&lt;std::pair&lt;const&nbsp;Key,&nbsp;Data&gt;&nbsp;&gt;&nbsp;&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;ordered_multi&nbsp;:&nbsp;public&nbsp;std::multimap&lt;Key,&nbsp;Data,&nbsp;Compare,&nbsp;Alloc&gt;&nbsp;{};<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;unordered&nbsp;map&nbsp;--&nbsp;will&nbsp;use&nbsp;TR1&nbsp;when&nbsp;available<BR>
&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;&lt;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;Key,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typename&nbsp;Data,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Hash&nbsp;=&nbsp;boost::hash&lt;Key&gt;,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Pred&nbsp;=&nbsp;std::equal_to&lt;Key&gt;,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Alloc&nbsp;=&nbsp;std::allocator&lt;std::pair&lt;const&nbsp;Key,&nbsp;Data&gt;&nbsp;&gt;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;cache_hash_code&nbsp;=&nbsp;false&nbsp;&gt;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;unordered&nbsp;:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;HAVE_TR1_UNORDERED_MAP<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;std::tr1::unordered_map&lt;Key,&nbsp;Data,&nbsp;Hash,&nbsp;Pred,&nbsp;Alloc,&nbsp;cache_hash_code&gt;&nbsp;{};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;std::map&lt;Key,&nbsp;Data,&nbsp;std::less&lt;Key&gt;,&nbsp;Alloc&gt;&nbsp;{};<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<BR>
<BR>
}&nbsp;//&nbsp;namespace&nbsp;maps<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is invoked in definition <A HREF="#13">13</A>.</FONT><BR>
<FONT COLOR=#CC0033>
<P><A NAME="13"></A><B>13. File:</B> semantic/utility.hpp={<FONT COLOR=#000033><TT><BR>
#ifndef&nbsp;_SEMANTIC_UTILITY_HPP_<BR>
#define&nbsp;_SEMANTIC_UTILITY_HPP_<BR>
<BR>
</TT>
<A HREF="#3">includes</A><TT><BR>
<BR>
namespace&nbsp;semantic&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#2">utility functions</A><TT><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;</TT>
<A HREF="#1">utility classes</A><TT><BR>
}&nbsp;//&nbsp;namespace&nbsp;semantic<BR>
<BR>
</TT>
<A HREF="#12">maps namespace</A><TT><BR>
<BR>
#endif<BR>
</TT>
</FONT>}<BR>
</FONT>
<FONT SIZE=1>This macro is attached to an output file.</FONT>
<P>
<HR SIZE=4 NOSHADE>
<CENTER><B>End Of File</B></CENTER>
<HR SIZE=4 NOSHADE>
</BODY>

<!----------------------------------------------------------------------------->
<!--                   END OF AUTOMATICALLY GENERATED HTML FILE              -->
<!----------------------------------------------------------------------------->
</HTML>
